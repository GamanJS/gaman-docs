---

title: Interceptors

---

Normally, **Interceptor** is located in the `src/interceptors/**` folder. If you use `autoComposeInterceptor`, it will be automatically registered by the system.

![workflow interceptor](/img/workflow/interceptor.png)

**Interceptor** here will be executed after `middleware`, so the function of the interceptor is normally for specific routes only, but it can still be used for global.

Here are the functions of the interceptor:

- Handle Request Data or Response Data

- Transform request data before reaching the request handler.

- Transform response data before sending to the client.

- Validate data like `ctx.json()`, `ctx.formData()`, etc.

## Interceptor Definition

### `composeInterceptor()`

Here `interceptorCompose` will not be automatically registered by the system, so you have to register it manually to a specific route or as global.

Example:

 ```ts
 // UserInterceptor.ts
 import { composeInterceptor } from "@gaman/core"

 export default composeInterceptor((ctx, next, error) => {
   return next();
 })
 ```

Now here you need to register manually, here is the example

 ```ts
 // index.ts
 defineBootstrap((app) => {
   app.mount(UserInterceptor)
 })
 ```

Here is an example for a specific route

 ```ts
 // AppRoutes.ts
 export default composeRoutes((route) => {
   route.get('/', Handler).interceptor(UserInterceptor)

   // if you want to register many
   route.get('/user', Handler).interceptor([UserInterceptor, ValidationInterceptor])
 })
 ```

### `autoComposeInterceptor()`

Now `autoComposeInterceptor` here will be automatically registered to the system, with the requirement that it must be in the `src/interceptors/**` folder.

Example:

 ```ts
 // UserInterceptor.ts
 import { autoComposeInterceptor } from "@gaman/core"

 export default autoComposeInterceptor((ctx, next, error) => {
   return next();
 })
 ```

This will be automatically registered into the system, so no need to bother with manual registration.

## Parameters

In composeInterceptor there are 3 parameters: `ctx`, `next`, and `error`, here is the explanation and use of each parameter.

- `ctx` Interceptor Context, to take and manipulate request data before reaching the handler

- `next` To trigger the next handler and can manipulate response data before sending to the client

- `error` to throw if there is an error

Example of real work as follows:

 ```ts
 export default composeInterceptor(await (ctx, next, error) => {
   // PROCESS BEFORE HANDLER
   // MANIPULATION OR VALIDATION OF REQUEST DATA IS DONE HERE
   if(ctx.param('name') != 'Angga'){
     throw error('Name must be "angga"', 400)
     // here it will automatically respond with json
     /**
     * {
     *   statusCode: 400,
     *   message: 'Name must be "angga"'
     * }
     */
   }
   const response = await next(); // run the next handler
   // PROCESS AFTER HANDLER FINISHED
   // MANIPULATION OF RESPONSE DATA IS DONE HERE
   const body = JSON.parse(response.body);
   body['umur'] = 100;
   response.body = JSON.stringify(body);
   return response;
 })
 ```

### Error Response

The `error` function will automatically send a json response as follows

 ```json
 // HTTP STATUS 400
 {
   "statusCode": 400,  // default is 400 if changed error('msg', 404) will be 404
   "message": "Name must be 'angga'" // depends on the message set
 }
 ```

But if you want to change the error response, you can use `composeExceptionHandler`

I'll give a little example :)

 ```ts
 // UserException.ts
 export default composeExceptionHandler((err: Error) => {
   if(err instanceof InterceptorException){
     const ctx = err.context; // take request context
     const status = err.statusCode; // take statusCode
     const message = err.message; // take message;
     // change interceptor error response
     return Res.json({
       msg: message, // return message
       error: status > 299 // if status above 299 will be true then considered error
     }, {
       status: status,
       statusText: message,
     })
   }
 })
 ```

Then register the exception to the route you want, for example

 ```ts
 // single route
 route.get('/user', Handler).exception(UserException);

 // or directly group to avoid one by one
 route.group('/user', (route) => {
   // other routes
 }).exception(UserException)

 // or can register global
 app.mountException(UserException)
 ```

For more details, you can read in [exception documentation](/docs/overview/exceptions)

So when you call `throw error('not found', 404)` the response will be:

 ```json
 // HTTP STATUS CODE     404
 // HTTP STATUS MESSAGE  not found
 {
   "msg": "not found",
   "error": true
 }
 ```

## Transformation Methods

Here are utilities for you to use to make request data transformation easier, if not here you have to do it manually :)

### `ctx.transformJson()`

Transform json here is to change json data so you can use it in the next handler, example as follows:

 ```ts
 // UserInterceptor.ts
 export default composeInterceptor(async (ctx, next, error) => {
   const defaultJson = await ctx.json();

   if(defaultJson.name == 'Angga'){
     ctx.transformJson({
       name: 'Angga Ganteng'
     })
   }

   return next();
 })
 ```

Then you use it in your request handler

Example:

 ```ts
 route.get('/', async (ctx) => {
   const json = await ctx.json()
   return Res.text(json.name) // Angga Ganteng
 }).interceptor(UserInterceptor)
 ```

### `ctx.transformParams()`

This is for transforming URL parameters so in the next handler just use :)

 ```ts
 // UserInterceptor.ts
 export default composeInterceptor((ctx, next, error) => {
   // if age is not integer then parse integer directly
   if(typeof ctx.params.umur == 'string') {
     ctx.transformParams({
       umur: parseInt(ctx.params.umur)
     })
   }
   return next();
 })
 ```

Then you use it in your request handler

Example:

 ```ts
 route.get('/:umur', (ctx) => {
   const umur = ctx.params.umur; // automatically integer
   return Res.json({
     message: "OK!"
   })
 })
 ```

### `ctx.transformQuery()`

### `ctx.transformBody()`

### `ctx.transformText()`

All transformation methods are more or less the same usage, just to make it easier.

### Experiments

If you are very pro player :v actually you can change the ctx data directly like the `json` function, `formData` function, `header` function, etc.

Here is a simple example of direct `context` manipulation.

 ```ts
 // UserInterceptor.ts
 export default composeInterceptor((ctx, next, error) => {
   ctx.json = async () => {
     return {
       name: ctx.query('name'), // name from query ?name='abogoboga'
       umur: ctx.param('umur'), // age from param /:umur = /12
       credit: 'GamanJS' // custom
     }
   }
   return next();
 })
 ```

Usage in handler as follows

 ```ts
 route.get('/:umur', async (ctx) => {
   const json = await ctx.json()
   return Res.json(json);
   /**
   * {
   *    name: 'abogoboga',
   *    umur: 12,
   *    credit: 'GamanJS'
   * }
   */
 })
 ```